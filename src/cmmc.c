/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.13 Mon Oct  6 19:18:13 2025.
 */

#include <string.h>

#include "cmmc.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int cmmc_odrive_heartbeat_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_heartbeat_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_error, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->axis_current_state, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->controller_status, 0u, 0xffu);

    return (6);
}

int cmmc_odrive_heartbeat_unpack(
    struct cmmc_odrive_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->axis_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->axis_current_state = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->controller_status = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

int cmmc_odrive_heartbeat_init(struct cmmc_odrive_heartbeat_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_heartbeat_t));

    return 0;
}

uint32_t cmmc_odrive_heartbeat_axis_error_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_heartbeat_axis_error_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_heartbeat_axis_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_odrive_heartbeat_axis_current_state_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_odrive_heartbeat_axis_current_state_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_odrive_heartbeat_axis_current_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_odrive_heartbeat_controller_status_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_odrive_heartbeat_controller_status_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_odrive_heartbeat_controller_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_set_requested_state_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_set_requested_state_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_requested_state, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_requested_state, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_requested_state, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_requested_state, 24u, 0xffu);

    return (4);
}

int cmmc_odrive_set_requested_state_unpack(
    struct cmmc_odrive_set_requested_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->axis_requested_state = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int cmmc_odrive_set_requested_state_init(struct cmmc_odrive_set_requested_state_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_set_requested_state_t));

    return 0;
}

uint32_t cmmc_odrive_set_requested_state_axis_requested_state_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_set_requested_state_axis_requested_state_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_set_requested_state_axis_requested_state_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_encoder_estimates_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->encoder_pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->encoder_pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->encoder_pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->encoder_pos_estimate, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->encoder_vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->encoder_vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->encoder_vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->encoder_vel_estimate, 24u, 0xffu);

    return (8);
}

int cmmc_odrive_encoder_estimates_unpack(
    struct cmmc_odrive_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->encoder_pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->encoder_pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->encoder_pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->encoder_pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->encoder_vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->encoder_vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->encoder_vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->encoder_vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int cmmc_odrive_encoder_estimates_init(struct cmmc_odrive_encoder_estimates_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_encoder_estimates_t));

    return 0;
}

uint32_t cmmc_odrive_encoder_estimates_encoder_pos_estimate_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_encoder_estimates_encoder_pos_estimate_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_encoder_estimates_encoder_pos_estimate_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t cmmc_odrive_encoder_estimates_encoder_vel_estimate_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_encoder_estimates_encoder_vel_estimate_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_encoder_estimates_encoder_vel_estimate_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_set_input_vel_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_set_input_vel_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->input_vel, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->input_vel, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->input_vel, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->input_vel, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->torque_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->torque_ff, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->torque_ff, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->torque_ff, 24u, 0xffu);

    return (8);
}

int cmmc_odrive_set_input_vel_unpack(
    struct cmmc_odrive_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->input_vel = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->input_vel |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->input_vel |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->input_vel |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->torque_ff = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->torque_ff |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->torque_ff |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->torque_ff |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int cmmc_odrive_set_input_vel_init(struct cmmc_odrive_set_input_vel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_set_input_vel_t));

    return 0;
}

uint32_t cmmc_odrive_set_input_vel_input_vel_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_set_input_vel_input_vel_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_set_input_vel_input_vel_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t cmmc_odrive_set_input_vel_torque_ff_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_set_input_vel_torque_ff_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_set_input_vel_torque_ff_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_get_sensorless_estimates_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->sensorless_pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->sensorless_pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->sensorless_pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->sensorless_pos_estimate, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->sensorless_vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->sensorless_vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->sensorless_vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->sensorless_vel_estimate, 24u, 0xffu);

    return (8);
}

int cmmc_odrive_get_sensorless_estimates_unpack(
    struct cmmc_odrive_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->sensorless_pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->sensorless_pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->sensorless_pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->sensorless_pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->sensorless_vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->sensorless_vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->sensorless_vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->sensorless_vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int cmmc_odrive_get_sensorless_estimates_init(struct cmmc_odrive_get_sensorless_estimates_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_get_sensorless_estimates_t));

    return 0;
}

uint32_t cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_get_vbus_voltage_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->vbus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->vbus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->vbus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->vbus_voltage, 24u, 0xffu);

    return (4);
}

int cmmc_odrive_get_vbus_voltage_unpack(
    struct cmmc_odrive_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->vbus_voltage = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->vbus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->vbus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->vbus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int cmmc_odrive_get_vbus_voltage_init(struct cmmc_odrive_get_vbus_voltage_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_odrive_get_vbus_voltage_t));

    return 0;
}

uint32_t cmmc_odrive_get_vbus_voltage_vbus_voltage_encode(float value)
{
    return (uint32_t)(value);
}

float cmmc_odrive_get_vbus_voltage_vbus_voltage_decode(uint32_t value)
{
    return ((float)value);
}

bool cmmc_odrive_get_vbus_voltage_vbus_voltage_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int cmmc_odrive_clear_errors_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int cmmc_odrive_clear_errors_unpack(
    struct cmmc_odrive_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int cmmc_radio_control_pack(
    uint8_t *dst_p,
    const struct cmmc_radio_control_t *src_p,
    size_t size)
{
    uint16_t front_pitch;
    uint16_t front_roll;
    uint16_t rear_pitch;
    uint16_t steering;
    uint16_t throttle;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    throttle = (uint16_t)src_p->throttle;
    dst_p[0] |= pack_left_shift_u16(throttle, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(throttle, 8u, 0x07u);
    steering = (uint16_t)src_p->steering;
    dst_p[1] |= pack_left_shift_u16(steering, 3u, 0xf8u);
    dst_p[2] |= pack_right_shift_u16(steering, 5u, 0x3fu);
    front_pitch = (uint16_t)src_p->front_pitch;
    dst_p[2] |= pack_left_shift_u16(front_pitch, 6u, 0xc0u);
    dst_p[3] |= pack_right_shift_u16(front_pitch, 2u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(front_pitch, 10u, 0x01u);
    front_roll = (uint16_t)src_p->front_roll;
    dst_p[4] |= pack_left_shift_u16(front_roll, 1u, 0xfeu);
    dst_p[5] |= pack_right_shift_u16(front_roll, 7u, 0x0fu);
    rear_pitch = (uint16_t)src_p->rear_pitch;
    dst_p[5] |= pack_left_shift_u16(rear_pitch, 4u, 0xf0u);
    dst_p[6] |= pack_right_shift_u16(rear_pitch, 4u, 0x7fu);
    dst_p[7] |= pack_left_shift_u8(src_p->free_bits, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->arm_switch, 4u, 0x30u);
    dst_p[7] |= pack_left_shift_u8(src_p->mode_switch, 6u, 0xc0u);

    return (8);
}

int cmmc_radio_control_unpack(
    struct cmmc_radio_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t front_pitch;
    uint16_t front_roll;
    uint16_t rear_pitch;
    uint16_t steering;
    uint16_t throttle;

    if (size < 8u) {
        return (-EINVAL);
    }

    throttle = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    throttle |= unpack_left_shift_u16(src_p[1], 8u, 0x07u);

    if ((throttle & (1u << 10)) != 0u) {
        throttle |= 0xf800u;
    }

    dst_p->throttle = (int16_t)throttle;
    steering = unpack_right_shift_u16(src_p[1], 3u, 0xf8u);
    steering |= unpack_left_shift_u16(src_p[2], 5u, 0x3fu);

    if ((steering & (1u << 10)) != 0u) {
        steering |= 0xf800u;
    }

    dst_p->steering = (int16_t)steering;
    front_pitch = unpack_right_shift_u16(src_p[2], 6u, 0xc0u);
    front_pitch |= unpack_left_shift_u16(src_p[3], 2u, 0xffu);
    front_pitch |= unpack_left_shift_u16(src_p[4], 10u, 0x01u);

    if ((front_pitch & (1u << 10)) != 0u) {
        front_pitch |= 0xf800u;
    }

    dst_p->front_pitch = (int16_t)front_pitch;
    front_roll = unpack_right_shift_u16(src_p[4], 1u, 0xfeu);
    front_roll |= unpack_left_shift_u16(src_p[5], 7u, 0x0fu);

    if ((front_roll & (1u << 10)) != 0u) {
        front_roll |= 0xf800u;
    }

    dst_p->front_roll = (int16_t)front_roll;
    rear_pitch = unpack_right_shift_u16(src_p[5], 4u, 0xf0u);
    rear_pitch |= unpack_left_shift_u16(src_p[6], 4u, 0x7fu);

    if ((rear_pitch & (1u << 10)) != 0u) {
        rear_pitch |= 0xf800u;
    }

    dst_p->rear_pitch = (int16_t)rear_pitch;
    dst_p->free_bits = unpack_right_shift_u8(src_p[7], 0u, 0x0fu);
    dst_p->arm_switch = unpack_right_shift_u8(src_p[7], 4u, 0x30u);
    dst_p->mode_switch = unpack_right_shift_u8(src_p[7], 6u, 0xc0u);

    return (0);
}

int cmmc_radio_control_init(struct cmmc_radio_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_radio_control_t));

    return 0;
}

int16_t cmmc_radio_control_throttle_encode(float value)
{
    return (int16_t)(value);
}

float cmmc_radio_control_throttle_decode(int16_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_throttle_is_in_range(int16_t value)
{
    return ((value >= -1000) && (value <= 1000));
}

int16_t cmmc_radio_control_steering_encode(float value)
{
    return (int16_t)(value);
}

float cmmc_radio_control_steering_decode(int16_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_steering_is_in_range(int16_t value)
{
    return ((value >= -1000) && (value <= 1000));
}

int16_t cmmc_radio_control_front_pitch_encode(float value)
{
    return (int16_t)(value);
}

float cmmc_radio_control_front_pitch_decode(int16_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_front_pitch_is_in_range(int16_t value)
{
    return ((value >= -1000) && (value <= 1000));
}

int16_t cmmc_radio_control_front_roll_encode(float value)
{
    return (int16_t)(value);
}

float cmmc_radio_control_front_roll_decode(int16_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_front_roll_is_in_range(int16_t value)
{
    return ((value >= -1000) && (value <= 1000));
}

int16_t cmmc_radio_control_rear_pitch_encode(float value)
{
    return (int16_t)(value);
}

float cmmc_radio_control_rear_pitch_decode(int16_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_rear_pitch_is_in_range(int16_t value)
{
    return ((value >= -1000) && (value <= 1000));
}

uint8_t cmmc_radio_control_free_bits_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_radio_control_free_bits_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_free_bits_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t cmmc_radio_control_arm_switch_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_radio_control_arm_switch_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_arm_switch_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t cmmc_radio_control_mode_switch_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_radio_control_mode_switch_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_radio_control_mode_switch_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int cmmc_actuator_configuration_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_configuration_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->request, 0u, 0x0fu);
    dst_p[0] |= pack_left_shift_u8(src_p->actuator, 4u, 0xf0u);

    return (1);
}

int cmmc_actuator_configuration_unpack(
    struct cmmc_actuator_configuration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->request = unpack_right_shift_u8(src_p[0], 0u, 0x0fu);
    dst_p->actuator = unpack_right_shift_u8(src_p[0], 4u, 0xf0u);

    return (0);
}

int cmmc_actuator_configuration_init(struct cmmc_actuator_configuration_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_actuator_configuration_t));

    return 0;
}

uint8_t cmmc_actuator_configuration_request_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_configuration_request_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_configuration_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t cmmc_actuator_configuration_actuator_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_configuration_actuator_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_configuration_actuator_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int cmmc_actuator_right_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_right_foil_feedback_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    current = (uint16_t)src_p->current;
    dst_p[0] |= pack_left_shift_u16(current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(current, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->voltage, 2u, 0xfcu);
    dst_p[2] |= pack_right_shift_u16(src_p->voltage, 6u, 0x0fu);
    power = (uint8_t)src_p->power;
    dst_p[2] |= pack_left_shift_u8(power, 4u, 0xf0u);
    dst_p[3] |= pack_right_shift_u8(power, 4u, 0x0fu);
    dst_p[3] |= pack_left_shift_u16(src_p->setpoint_us, 4u, 0xf0u);
    dst_p[4] |= pack_right_shift_u16(src_p->setpoint_us, 4u, 0x3fu);
    dst_p[4] |= pack_left_shift_u16(src_p->position_raw, 6u, 0xc0u);
    dst_p[5] |= pack_right_shift_u16(src_p->position_raw, 2u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->position_raw, 10u, 0x03u);
    dst_p[6] |= pack_left_shift_u16(src_p->free_bits, 2u, 0xfcu);
    dst_p[7] |= pack_right_shift_u16(src_p->free_bits, 6u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mode, 4u, 0xf0u);

    return (8);
}

int cmmc_actuator_right_foil_feedback_unpack(
    struct cmmc_actuator_right_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    current |= unpack_left_shift_u16(src_p[1], 8u, 0x03u);

    if ((current & (1u << 9)) != 0u) {
        current |= 0xfc00u;
    }

    dst_p->current = (int16_t)current;
    dst_p->voltage = unpack_right_shift_u16(src_p[1], 2u, 0xfcu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[2], 6u, 0x0fu);
    power = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    power |= unpack_left_shift_u8(src_p[3], 4u, 0x0fu);
    dst_p->power = (int8_t)power;
    dst_p->setpoint_us = unpack_right_shift_u16(src_p[3], 4u, 0xf0u);
    dst_p->setpoint_us |= unpack_left_shift_u16(src_p[4], 4u, 0x3fu);
    dst_p->position_raw = unpack_right_shift_u16(src_p[4], 6u, 0xc0u);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[5], 2u, 0xffu);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[6], 10u, 0x03u);
    dst_p->free_bits = unpack_right_shift_u16(src_p[6], 2u, 0xfcu);
    dst_p->free_bits |= unpack_left_shift_u16(src_p[7], 6u, 0x0fu);
    dst_p->mode = unpack_right_shift_u8(src_p[7], 4u, 0xf0u);

    return (0);
}

int cmmc_actuator_right_foil_feedback_init(struct cmmc_actuator_right_foil_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_actuator_right_foil_feedback_t));

    return 0;
}

int16_t cmmc_actuator_right_foil_feedback_current_encode(float value)
{
    return (int16_t)(value / 0.002f);
}

float cmmc_actuator_right_foil_feedback_current_decode(int16_t value)
{
    return ((float)value * 0.002f);
}

bool cmmc_actuator_right_foil_feedback_current_is_in_range(int16_t value)
{
    return ((value >= -500) && (value <= 500));
}

uint16_t cmmc_actuator_right_foil_feedback_voltage_encode(float value)
{
    return (uint16_t)((value - 3.6f) / 0.003f);
}

float cmmc_actuator_right_foil_feedback_voltage_decode(uint16_t value)
{
    return (((float)value * 0.003f) + 3.6f);
}

bool cmmc_actuator_right_foil_feedback_voltage_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

int8_t cmmc_actuator_right_foil_feedback_power_encode(float value)
{
    return (int8_t)(value / 0.05f);
}

float cmmc_actuator_right_foil_feedback_power_decode(int8_t value)
{
    return ((float)value * 0.05f);
}

bool cmmc_actuator_right_foil_feedback_power_is_in_range(int8_t value)
{
    return ((value >= -120) && (value <= 120));
}

uint16_t cmmc_actuator_right_foil_feedback_setpoint_us_encode(float value)
{
    return (uint16_t)(value - 988.0f);
}

float cmmc_actuator_right_foil_feedback_setpoint_us_decode(uint16_t value)
{
    return ((float)value + 988.0f);
}

bool cmmc_actuator_right_foil_feedback_setpoint_us_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint16_t cmmc_actuator_right_foil_feedback_position_raw_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_right_foil_feedback_position_raw_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_right_foil_feedback_position_raw_is_in_range(uint16_t value)
{
    return (value <= 4091u);
}

uint16_t cmmc_actuator_right_foil_feedback_free_bits_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_right_foil_feedback_free_bits_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_right_foil_feedback_free_bits_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t cmmc_actuator_right_foil_feedback_mode_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_right_foil_feedback_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_right_foil_feedback_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int cmmc_actuator_left_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_left_foil_feedback_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    current = (uint16_t)src_p->current;
    dst_p[0] |= pack_left_shift_u16(current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(current, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->voltage, 2u, 0xfcu);
    dst_p[2] |= pack_right_shift_u16(src_p->voltage, 6u, 0x0fu);
    power = (uint8_t)src_p->power;
    dst_p[2] |= pack_left_shift_u8(power, 4u, 0xf0u);
    dst_p[3] |= pack_right_shift_u8(power, 4u, 0x0fu);
    dst_p[3] |= pack_left_shift_u16(src_p->setpoint_us, 4u, 0xf0u);
    dst_p[4] |= pack_right_shift_u16(src_p->setpoint_us, 4u, 0x3fu);
    dst_p[4] |= pack_left_shift_u16(src_p->position_raw, 6u, 0xc0u);
    dst_p[5] |= pack_right_shift_u16(src_p->position_raw, 2u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->position_raw, 10u, 0x03u);
    dst_p[6] |= pack_left_shift_u16(src_p->free_bits, 2u, 0xfcu);
    dst_p[7] |= pack_right_shift_u16(src_p->free_bits, 6u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mode, 4u, 0xf0u);

    return (8);
}

int cmmc_actuator_left_foil_feedback_unpack(
    struct cmmc_actuator_left_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    current |= unpack_left_shift_u16(src_p[1], 8u, 0x03u);

    if ((current & (1u << 9)) != 0u) {
        current |= 0xfc00u;
    }

    dst_p->current = (int16_t)current;
    dst_p->voltage = unpack_right_shift_u16(src_p[1], 2u, 0xfcu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[2], 6u, 0x0fu);
    power = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    power |= unpack_left_shift_u8(src_p[3], 4u, 0x0fu);
    dst_p->power = (int8_t)power;
    dst_p->setpoint_us = unpack_right_shift_u16(src_p[3], 4u, 0xf0u);
    dst_p->setpoint_us |= unpack_left_shift_u16(src_p[4], 4u, 0x3fu);
    dst_p->position_raw = unpack_right_shift_u16(src_p[4], 6u, 0xc0u);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[5], 2u, 0xffu);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[6], 10u, 0x03u);
    dst_p->free_bits = unpack_right_shift_u16(src_p[6], 2u, 0xfcu);
    dst_p->free_bits |= unpack_left_shift_u16(src_p[7], 6u, 0x0fu);
    dst_p->mode = unpack_right_shift_u8(src_p[7], 4u, 0xf0u);

    return (0);
}

int cmmc_actuator_left_foil_feedback_init(struct cmmc_actuator_left_foil_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_actuator_left_foil_feedback_t));

    return 0;
}

int16_t cmmc_actuator_left_foil_feedback_current_encode(float value)
{
    return (int16_t)(value / 0.002f);
}

float cmmc_actuator_left_foil_feedback_current_decode(int16_t value)
{
    return ((float)value * 0.002f);
}

bool cmmc_actuator_left_foil_feedback_current_is_in_range(int16_t value)
{
    return ((value >= -500) && (value <= 500));
}

uint16_t cmmc_actuator_left_foil_feedback_voltage_encode(float value)
{
    return (uint16_t)((value - 3.6f) / 0.003f);
}

float cmmc_actuator_left_foil_feedback_voltage_decode(uint16_t value)
{
    return (((float)value * 0.003f) + 3.6f);
}

bool cmmc_actuator_left_foil_feedback_voltage_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

int8_t cmmc_actuator_left_foil_feedback_power_encode(float value)
{
    return (int8_t)(value / 0.05f);
}

float cmmc_actuator_left_foil_feedback_power_decode(int8_t value)
{
    return ((float)value * 0.05f);
}

bool cmmc_actuator_left_foil_feedback_power_is_in_range(int8_t value)
{
    return ((value >= -120) && (value <= 120));
}

uint16_t cmmc_actuator_left_foil_feedback_setpoint_us_encode(float value)
{
    return (uint16_t)(value - 988.0f);
}

float cmmc_actuator_left_foil_feedback_setpoint_us_decode(uint16_t value)
{
    return ((float)value + 988.0f);
}

bool cmmc_actuator_left_foil_feedback_setpoint_us_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint16_t cmmc_actuator_left_foil_feedback_position_raw_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_left_foil_feedback_position_raw_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_left_foil_feedback_position_raw_is_in_range(uint16_t value)
{
    return (value <= 4091u);
}

uint16_t cmmc_actuator_left_foil_feedback_free_bits_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_left_foil_feedback_free_bits_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_left_foil_feedback_free_bits_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t cmmc_actuator_left_foil_feedback_mode_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_left_foil_feedback_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_left_foil_feedback_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int cmmc_actuator_rear_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_rear_foil_feedback_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    current = (uint16_t)src_p->current;
    dst_p[0] |= pack_left_shift_u16(current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(current, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->voltage, 2u, 0xfcu);
    dst_p[2] |= pack_right_shift_u16(src_p->voltage, 6u, 0x0fu);
    power = (uint8_t)src_p->power;
    dst_p[2] |= pack_left_shift_u8(power, 4u, 0xf0u);
    dst_p[3] |= pack_right_shift_u8(power, 4u, 0x0fu);
    dst_p[3] |= pack_left_shift_u16(src_p->setpoint_us, 4u, 0xf0u);
    dst_p[4] |= pack_right_shift_u16(src_p->setpoint_us, 4u, 0x3fu);
    dst_p[4] |= pack_left_shift_u16(src_p->position_raw, 6u, 0xc0u);
    dst_p[5] |= pack_right_shift_u16(src_p->position_raw, 2u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->position_raw, 10u, 0x03u);
    dst_p[6] |= pack_left_shift_u16(src_p->free_bits, 2u, 0xfcu);
    dst_p[7] |= pack_right_shift_u16(src_p->free_bits, 6u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mode, 4u, 0xf0u);

    return (8);
}

int cmmc_actuator_rear_foil_feedback_unpack(
    struct cmmc_actuator_rear_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    current |= unpack_left_shift_u16(src_p[1], 8u, 0x03u);

    if ((current & (1u << 9)) != 0u) {
        current |= 0xfc00u;
    }

    dst_p->current = (int16_t)current;
    dst_p->voltage = unpack_right_shift_u16(src_p[1], 2u, 0xfcu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[2], 6u, 0x0fu);
    power = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    power |= unpack_left_shift_u8(src_p[3], 4u, 0x0fu);
    dst_p->power = (int8_t)power;
    dst_p->setpoint_us = unpack_right_shift_u16(src_p[3], 4u, 0xf0u);
    dst_p->setpoint_us |= unpack_left_shift_u16(src_p[4], 4u, 0x3fu);
    dst_p->position_raw = unpack_right_shift_u16(src_p[4], 6u, 0xc0u);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[5], 2u, 0xffu);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[6], 10u, 0x03u);
    dst_p->free_bits = unpack_right_shift_u16(src_p[6], 2u, 0xfcu);
    dst_p->free_bits |= unpack_left_shift_u16(src_p[7], 6u, 0x0fu);
    dst_p->mode = unpack_right_shift_u8(src_p[7], 4u, 0xf0u);

    return (0);
}

int cmmc_actuator_rear_foil_feedback_init(struct cmmc_actuator_rear_foil_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_actuator_rear_foil_feedback_t));

    return 0;
}

int16_t cmmc_actuator_rear_foil_feedback_current_encode(float value)
{
    return (int16_t)(value / 0.002f);
}

float cmmc_actuator_rear_foil_feedback_current_decode(int16_t value)
{
    return ((float)value * 0.002f);
}

bool cmmc_actuator_rear_foil_feedback_current_is_in_range(int16_t value)
{
    return ((value >= -500) && (value <= 500));
}

uint16_t cmmc_actuator_rear_foil_feedback_voltage_encode(float value)
{
    return (uint16_t)((value - 3.6f) / 0.003f);
}

float cmmc_actuator_rear_foil_feedback_voltage_decode(uint16_t value)
{
    return (((float)value * 0.003f) + 3.6f);
}

bool cmmc_actuator_rear_foil_feedback_voltage_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

int8_t cmmc_actuator_rear_foil_feedback_power_encode(float value)
{
    return (int8_t)(value / 0.05f);
}

float cmmc_actuator_rear_foil_feedback_power_decode(int8_t value)
{
    return ((float)value * 0.05f);
}

bool cmmc_actuator_rear_foil_feedback_power_is_in_range(int8_t value)
{
    return ((value >= -120) && (value <= 120));
}

uint16_t cmmc_actuator_rear_foil_feedback_setpoint_us_encode(float value)
{
    return (uint16_t)(value - 988.0f);
}

float cmmc_actuator_rear_foil_feedback_setpoint_us_decode(uint16_t value)
{
    return ((float)value + 988.0f);
}

bool cmmc_actuator_rear_foil_feedback_setpoint_us_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint16_t cmmc_actuator_rear_foil_feedback_position_raw_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_rear_foil_feedback_position_raw_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_rear_foil_feedback_position_raw_is_in_range(uint16_t value)
{
    return (value <= 4091u);
}

uint16_t cmmc_actuator_rear_foil_feedback_free_bits_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_rear_foil_feedback_free_bits_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_rear_foil_feedback_free_bits_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t cmmc_actuator_rear_foil_feedback_mode_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_rear_foil_feedback_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_rear_foil_feedback_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int cmmc_actuator_steering_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_steering_feedback_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    current = (uint16_t)src_p->current;
    dst_p[0] |= pack_left_shift_u16(current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(current, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->voltage, 2u, 0xfcu);
    dst_p[2] |= pack_right_shift_u16(src_p->voltage, 6u, 0x0fu);
    power = (uint8_t)src_p->power;
    dst_p[2] |= pack_left_shift_u8(power, 4u, 0xf0u);
    dst_p[3] |= pack_right_shift_u8(power, 4u, 0x0fu);
    dst_p[3] |= pack_left_shift_u16(src_p->setpoint_us, 4u, 0xf0u);
    dst_p[4] |= pack_right_shift_u16(src_p->setpoint_us, 4u, 0x3fu);
    dst_p[4] |= pack_left_shift_u16(src_p->position_raw, 6u, 0xc0u);
    dst_p[5] |= pack_right_shift_u16(src_p->position_raw, 2u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->position_raw, 10u, 0x03u);
    dst_p[6] |= pack_left_shift_u16(src_p->free_bits, 2u, 0xfcu);
    dst_p[7] |= pack_right_shift_u16(src_p->free_bits, 6u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mode, 4u, 0xf0u);

    return (8);
}

int cmmc_actuator_steering_feedback_unpack(
    struct cmmc_actuator_steering_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t current;
    uint8_t power;

    if (size < 8u) {
        return (-EINVAL);
    }

    current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    current |= unpack_left_shift_u16(src_p[1], 8u, 0x03u);

    if ((current & (1u << 9)) != 0u) {
        current |= 0xfc00u;
    }

    dst_p->current = (int16_t)current;
    dst_p->voltage = unpack_right_shift_u16(src_p[1], 2u, 0xfcu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[2], 6u, 0x0fu);
    power = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    power |= unpack_left_shift_u8(src_p[3], 4u, 0x0fu);
    dst_p->power = (int8_t)power;
    dst_p->setpoint_us = unpack_right_shift_u16(src_p[3], 4u, 0xf0u);
    dst_p->setpoint_us |= unpack_left_shift_u16(src_p[4], 4u, 0x3fu);
    dst_p->position_raw = unpack_right_shift_u16(src_p[4], 6u, 0xc0u);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[5], 2u, 0xffu);
    dst_p->position_raw |= unpack_left_shift_u16(src_p[6], 10u, 0x03u);
    dst_p->free_bits = unpack_right_shift_u16(src_p[6], 2u, 0xfcu);
    dst_p->free_bits |= unpack_left_shift_u16(src_p[7], 6u, 0x0fu);
    dst_p->mode = unpack_right_shift_u8(src_p[7], 4u, 0xf0u);

    return (0);
}

int cmmc_actuator_steering_feedback_init(struct cmmc_actuator_steering_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_actuator_steering_feedback_t));

    return 0;
}

int16_t cmmc_actuator_steering_feedback_current_encode(float value)
{
    return (int16_t)(value / 0.002f);
}

float cmmc_actuator_steering_feedback_current_decode(int16_t value)
{
    return ((float)value * 0.002f);
}

bool cmmc_actuator_steering_feedback_current_is_in_range(int16_t value)
{
    return ((value >= -500) && (value <= 500));
}

uint16_t cmmc_actuator_steering_feedback_voltage_encode(float value)
{
    return (uint16_t)((value - 3.6f) / 0.003f);
}

float cmmc_actuator_steering_feedback_voltage_decode(uint16_t value)
{
    return (((float)value * 0.003f) + 3.6f);
}

bool cmmc_actuator_steering_feedback_voltage_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

int8_t cmmc_actuator_steering_feedback_power_encode(float value)
{
    return (int8_t)(value / 0.05f);
}

float cmmc_actuator_steering_feedback_power_decode(int8_t value)
{
    return ((float)value * 0.05f);
}

bool cmmc_actuator_steering_feedback_power_is_in_range(int8_t value)
{
    return ((value >= -120) && (value <= 120));
}

uint16_t cmmc_actuator_steering_feedback_setpoint_us_encode(float value)
{
    return (uint16_t)(value - 988.0f);
}

float cmmc_actuator_steering_feedback_setpoint_us_decode(uint16_t value)
{
    return ((float)value + 988.0f);
}

bool cmmc_actuator_steering_feedback_setpoint_us_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint16_t cmmc_actuator_steering_feedback_position_raw_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_steering_feedback_position_raw_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_steering_feedback_position_raw_is_in_range(uint16_t value)
{
    return (value <= 4091u);
}

uint16_t cmmc_actuator_steering_feedback_free_bits_encode(float value)
{
    return (uint16_t)(value);
}

float cmmc_actuator_steering_feedback_free_bits_decode(uint16_t value)
{
    return ((float)value);
}

bool cmmc_actuator_steering_feedback_free_bits_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t cmmc_actuator_steering_feedback_mode_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_actuator_steering_feedback_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_actuator_steering_feedback_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int cmmc_distance_fore_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_fore_feedback_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->range_mm_l, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->error_status_l, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->signal_rate_mcps_l, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->signal_rate_mcps_l, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->range_mm_r, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->error_status_r, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->signal_rate_mcps_r, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->signal_rate_mcps_r, 8u, 0xffu);

    return (8);
}

int cmmc_distance_fore_feedback_unpack(
    struct cmmc_distance_fore_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->range_mm_l = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->error_status_l = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->signal_rate_mcps_l = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->signal_rate_mcps_l |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->range_mm_r = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->error_status_r = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->signal_rate_mcps_r = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->signal_rate_mcps_r |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int cmmc_distance_fore_feedback_init(struct cmmc_distance_fore_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_distance_fore_feedback_t));

    return 0;
}

uint8_t cmmc_distance_fore_feedback_range_mm_l_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_fore_feedback_range_mm_l_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_fore_feedback_range_mm_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_distance_fore_feedback_error_status_l_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_fore_feedback_error_status_l_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_fore_feedback_error_status_l_is_in_range(uint8_t value)
{
    return (value <= 31u);
}

uint16_t cmmc_distance_fore_feedback_signal_rate_mcps_l_encode(float value)
{
    return (uint16_t)(value / 0.0078125f);
}

float cmmc_distance_fore_feedback_signal_rate_mcps_l_decode(uint16_t value)
{
    return ((float)value * 0.0078125f);
}

bool cmmc_distance_fore_feedback_signal_rate_mcps_l_is_in_range(uint16_t value)
{
    return (value <= 1280u);
}

uint8_t cmmc_distance_fore_feedback_range_mm_r_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_fore_feedback_range_mm_r_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_fore_feedback_range_mm_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_distance_fore_feedback_error_status_r_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_fore_feedback_error_status_r_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_fore_feedback_error_status_r_is_in_range(uint8_t value)
{
    return (value <= 31u);
}

uint16_t cmmc_distance_fore_feedback_signal_rate_mcps_r_encode(float value)
{
    return (uint16_t)(value / 0.0078125f);
}

float cmmc_distance_fore_feedback_signal_rate_mcps_r_decode(uint16_t value)
{
    return ((float)value * 0.0078125f);
}

bool cmmc_distance_fore_feedback_signal_rate_mcps_r_is_in_range(uint16_t value)
{
    return (value <= 1280u);
}

int cmmc_distance_achter_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_achter_feedback_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->range_mm_l, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->error_status_l, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->signal_rate_mcps_l, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->signal_rate_mcps_l, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->range_mm_r, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->error_status_r, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->signal_rate_mcps_r, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->signal_rate_mcps_r, 8u, 0xffu);

    return (8);
}

int cmmc_distance_achter_feedback_unpack(
    struct cmmc_distance_achter_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->range_mm_l = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->error_status_l = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->signal_rate_mcps_l = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->signal_rate_mcps_l |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->range_mm_r = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->error_status_r = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->signal_rate_mcps_r = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->signal_rate_mcps_r |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int cmmc_distance_achter_feedback_init(struct cmmc_distance_achter_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_distance_achter_feedback_t));

    return 0;
}

uint8_t cmmc_distance_achter_feedback_range_mm_l_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_achter_feedback_range_mm_l_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_achter_feedback_range_mm_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_distance_achter_feedback_error_status_l_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_achter_feedback_error_status_l_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_achter_feedback_error_status_l_is_in_range(uint8_t value)
{
    return (value <= 31u);
}

uint16_t cmmc_distance_achter_feedback_signal_rate_mcps_l_encode(float value)
{
    return (uint16_t)(value / 0.0078125f);
}

float cmmc_distance_achter_feedback_signal_rate_mcps_l_decode(uint16_t value)
{
    return ((float)value * 0.0078125f);
}

bool cmmc_distance_achter_feedback_signal_rate_mcps_l_is_in_range(uint16_t value)
{
    return (value <= 1280u);
}

uint8_t cmmc_distance_achter_feedback_range_mm_r_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_achter_feedback_range_mm_r_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_achter_feedback_range_mm_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_distance_achter_feedback_error_status_r_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_achter_feedback_error_status_r_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_achter_feedback_error_status_r_is_in_range(uint8_t value)
{
    return (value <= 31u);
}

uint16_t cmmc_distance_achter_feedback_signal_rate_mcps_r_encode(float value)
{
    return (uint16_t)(value / 0.0078125f);
}

float cmmc_distance_achter_feedback_signal_rate_mcps_r_decode(uint16_t value)
{
    return ((float)value * 0.0078125f);
}

bool cmmc_distance_achter_feedback_signal_rate_mcps_r_is_in_range(uint16_t value)
{
    return (value <= 1280u);
}

int cmmc_distance_bow_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_bow_feedback_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->range_mm, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->error_status, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->signal_rate_mcps, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->signal_rate_mcps, 8u, 0xffu);

    return (4);
}

int cmmc_distance_bow_feedback_unpack(
    struct cmmc_distance_bow_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->range_mm = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->error_status = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->signal_rate_mcps = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->signal_rate_mcps |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int cmmc_distance_bow_feedback_init(struct cmmc_distance_bow_feedback_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct cmmc_distance_bow_feedback_t));

    return 0;
}

uint8_t cmmc_distance_bow_feedback_range_mm_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_bow_feedback_range_mm_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_bow_feedback_range_mm_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t cmmc_distance_bow_feedback_error_status_encode(float value)
{
    return (uint8_t)(value);
}

float cmmc_distance_bow_feedback_error_status_decode(uint8_t value)
{
    return ((float)value);
}

bool cmmc_distance_bow_feedback_error_status_is_in_range(uint8_t value)
{
    return (value <= 31u);
}

uint16_t cmmc_distance_bow_feedback_signal_rate_mcps_encode(float value)
{
    return (uint16_t)(value / 0.0078125f);
}

float cmmc_distance_bow_feedback_signal_rate_mcps_decode(uint16_t value)
{
    return ((float)value * 0.0078125f);
}

bool cmmc_distance_bow_feedback_signal_rate_mcps_is_in_range(uint16_t value)
{
    return (value <= 1280u);
}
