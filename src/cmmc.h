/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.13 Wed Oct 15 14:56:42 2025.
 */

#ifndef CMMC_H
#define CMMC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CMMC_ODRIVE_HEARTBEAT_FRAME_ID (0x01u)
#define CMMC_ODRIVE_SET_REQUESTED_STATE_FRAME_ID (0x07u)
#define CMMC_ODRIVE_SET_INPUT_VEL_FRAME_ID (0x0du)
#define CMMC_ODRIVE_GET_IQ_FRAME_ID (0x14u)
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x15u)
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_FRAME_ID (0x17u)
#define CMMC_ODRIVE_CLEAR_ERRORS_FRAME_ID (0x18u)
#define CMMC_RADIO_CONTROL_FRAME_ID (0x20u)
#define CMMC_ACTUATOR_CONFIGURATION_FRAME_ID (0x27u)
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_FRAME_ID (0x28u)
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_FRAME_ID (0x29u)
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_FRAME_ID (0x2au)
#define CMMC_ACTUATOR_STEERING_FEEDBACK_FRAME_ID (0x2bu)
#define CMMC_DISTANCE_FORE_FEEDBACK_FRAME_ID (0x2cu)
#define CMMC_DISTANCE_ACHTER_FEEDBACK_FRAME_ID (0x2du)
#define CMMC_DISTANCE_BOW_FEEDBACK_FRAME_ID (0x2eu)

/* Frame lengths in bytes. */
#define CMMC_ODRIVE_HEARTBEAT_LENGTH (8u)
#define CMMC_ODRIVE_SET_REQUESTED_STATE_LENGTH (4u)
#define CMMC_ODRIVE_SET_INPUT_VEL_LENGTH (8u)
#define CMMC_ODRIVE_GET_IQ_LENGTH (8u)
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_LENGTH (8u)
#define CMMC_ODRIVE_CLEAR_ERRORS_LENGTH (0u)
#define CMMC_RADIO_CONTROL_LENGTH (8u)
#define CMMC_ACTUATOR_CONFIGURATION_LENGTH (1u)
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_LENGTH (8u)
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_LENGTH (8u)
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_LENGTH (8u)
#define CMMC_ACTUATOR_STEERING_FEEDBACK_LENGTH (8u)
#define CMMC_DISTANCE_FORE_FEEDBACK_LENGTH (8u)
#define CMMC_DISTANCE_ACHTER_FEEDBACK_LENGTH (8u)
#define CMMC_DISTANCE_BOW_FEEDBACK_LENGTH (4u)

/* Extended or standard frame types. */
#define CMMC_ODRIVE_HEARTBEAT_IS_EXTENDED (0)
#define CMMC_ODRIVE_SET_REQUESTED_STATE_IS_EXTENDED (0)
#define CMMC_ODRIVE_SET_INPUT_VEL_IS_EXTENDED (0)
#define CMMC_ODRIVE_GET_IQ_IS_EXTENDED (0)
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_IS_EXTENDED (0)
#define CMMC_ODRIVE_CLEAR_ERRORS_IS_EXTENDED (0)
#define CMMC_RADIO_CONTROL_IS_EXTENDED (0)
#define CMMC_ACTUATOR_CONFIGURATION_IS_EXTENDED (0)
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_IS_EXTENDED (0)
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_IS_EXTENDED (0)
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_IS_EXTENDED (0)
#define CMMC_ACTUATOR_STEERING_FEEDBACK_IS_EXTENDED (0)
#define CMMC_DISTANCE_FORE_FEEDBACK_IS_EXTENDED (0)
#define CMMC_DISTANCE_ACHTER_FEEDBACK_IS_EXTENDED (0)
#define CMMC_DISTANCE_BOW_FEEDBACK_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CMMC_ACTUATOR_CONFIGURATION_REQUEST_NONE_CHOICE (0u)
#define CMMC_ACTUATOR_CONFIGURATION_REQUEST_ON_CHOICE (1u)
#define CMMC_ACTUATOR_CONFIGURATION_REQUEST_OFF_CHOICE (2u)
#define CMMC_ACTUATOR_CONFIGURATION_REQUEST_AUTO_CALIBRATION_CHOICE (3u)

#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_NONE_CHOICE (0u)
#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_STEERING_CHOICE (1u)
#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_RIGHT_FOIL_CHOICE (2u)
#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_LEFT_FOIL_CHOICE (3u)
#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_REAR_FOIL_CHOICE (4u)

/* Frame Names. */
#define CMMC_ODRIVE_HEARTBEAT_NAME "ODRIVE_HEARTBEAT"
#define CMMC_ODRIVE_SET_REQUESTED_STATE_NAME "ODRIVE_SET_REQUESTED_STATE"
#define CMMC_ODRIVE_SET_INPUT_VEL_NAME "ODRIVE_SET_INPUT_VEL"
#define CMMC_ODRIVE_GET_IQ_NAME "ODRIVE_GET_IQ"
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_NAME "ODRIVE_GET_SENSORLESS_ESTIMATES"
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_NAME "ODRIVE_GET_BUS_VOLTAGE_CURRENT"
#define CMMC_ODRIVE_CLEAR_ERRORS_NAME "ODRIVE_CLEAR_ERRORS"
#define CMMC_RADIO_CONTROL_NAME "RADIO_CONTROL"
#define CMMC_ACTUATOR_CONFIGURATION_NAME "ACTUATOR_CONFIGURATION"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_NAME "ACTUATOR_RIGHT_FOIL_FEEDBACK"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_NAME "ACTUATOR_LEFT_FOIL_FEEDBACK"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_NAME "ACTUATOR_REAR_FOIL_FEEDBACK"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_NAME "ACTUATOR_STEERING_FEEDBACK"
#define CMMC_DISTANCE_FORE_FEEDBACK_NAME "DISTANCE_FORE_FEEDBACK"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_NAME "DISTANCE_ACHTER_FEEDBACK"
#define CMMC_DISTANCE_BOW_FEEDBACK_NAME "DISTANCE_BOW_FEEDBACK"

/* Signal Names. */
#define CMMC_ODRIVE_HEARTBEAT_AXIS_ERROR_NAME "Axis_Error"
#define CMMC_ODRIVE_HEARTBEAT_AXIS_CURRENT_STATE_NAME "Axis_Current_State"
#define CMMC_ODRIVE_HEARTBEAT_MOTOR_ERROR_FLAG_NAME "Motor_Error_Flag"
#define CMMC_ODRIVE_HEARTBEAT_ENCODER_ERROR_FLAG_NAME "Encoder_Error_Flag"
#define CMMC_ODRIVE_HEARTBEAT_CONTROLLER_ERROR_FLAG_NAME "Controller_Error_Flag"
#define CMMC_ODRIVE_HEARTBEAT_TRAJECTORY_DONE_FLAG_NAME "Trajectory_Done_Flag"
#define CMMC_ODRIVE_SET_REQUESTED_STATE_AXIS_REQUESTED_STATE_NAME "Axis_Requested_State"
#define CMMC_ODRIVE_SET_INPUT_VEL_INPUT_VEL_NAME "Input_Vel"
#define CMMC_ODRIVE_SET_INPUT_VEL_TORQUE_FF_NAME "Torque_FF"
#define CMMC_ODRIVE_GET_IQ_IQ_SETPOINT_NAME "Iq_Setpoint"
#define CMMC_ODRIVE_GET_IQ_IQ_MEASURED_NAME "Iq_Measured"
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_SENSORLESS_POS_ESTIMATE_NAME "Sensorless_Pos_Estimate"
#define CMMC_ODRIVE_GET_SENSORLESS_ESTIMATES_SENSORLESS_VEL_ESTIMATE_NAME "Sensorless_Vel_Estimate"
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_BUS_VOLTAGE_NAME "Bus_Voltage"
#define CMMC_ODRIVE_GET_BUS_VOLTAGE_CURRENT_BUS_CURRENT_NAME "Bus_Current"
#define CMMC_RADIO_CONTROL_THROTTLE_NAME "THROTTLE"
#define CMMC_RADIO_CONTROL_STEERING_NAME "STEERING"
#define CMMC_RADIO_CONTROL_FRONT_PITCH_NAME "FRONT_PITCH"
#define CMMC_RADIO_CONTROL_FRONT_ROLL_NAME "FRONT_ROLL"
#define CMMC_RADIO_CONTROL_REAR_PITCH_NAME "REAR_PITCH"
#define CMMC_RADIO_CONTROL_FREE_BITS_NAME "FREE_BITS"
#define CMMC_RADIO_CONTROL_ARM_SWITCH_NAME "ARM_SWITCH"
#define CMMC_RADIO_CONTROL_MODE_SWITCH_NAME "MODE_SWITCH"
#define CMMC_ACTUATOR_CONFIGURATION_REQUEST_NAME "REQUEST"
#define CMMC_ACTUATOR_CONFIGURATION_ACTUATOR_NAME "ACTUATOR"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_CURRENT_NAME "CURRENT"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_VOLTAGE_NAME "VOLTAGE"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_POWER_NAME "POWER"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_SETPOINT_US_NAME "SETPOINT_US"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_POSITION_RAW_NAME "POSITION_RAW"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_FREE_BITS_NAME "FREE_BITS"
#define CMMC_ACTUATOR_RIGHT_FOIL_FEEDBACK_MODE_NAME "MODE"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_CURRENT_NAME "CURRENT"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_VOLTAGE_NAME "VOLTAGE"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_POWER_NAME "POWER"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_SETPOINT_US_NAME "SETPOINT_US"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_POSITION_RAW_NAME "POSITION_RAW"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_FREE_BITS_NAME "FREE_BITS"
#define CMMC_ACTUATOR_LEFT_FOIL_FEEDBACK_MODE_NAME "MODE"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_CURRENT_NAME "CURRENT"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_VOLTAGE_NAME "VOLTAGE"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_POWER_NAME "POWER"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_SETPOINT_US_NAME "SETPOINT_US"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_POSITION_RAW_NAME "POSITION_RAW"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_FREE_BITS_NAME "FREE_BITS"
#define CMMC_ACTUATOR_REAR_FOIL_FEEDBACK_MODE_NAME "MODE"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_CURRENT_NAME "CURRENT"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_VOLTAGE_NAME "VOLTAGE"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_POWER_NAME "POWER"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_SETPOINT_US_NAME "SETPOINT_US"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_POSITION_RAW_NAME "POSITION_RAW"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_FREE_BITS_NAME "FREE_BITS"
#define CMMC_ACTUATOR_STEERING_FEEDBACK_MODE_NAME "MODE"
#define CMMC_DISTANCE_FORE_FEEDBACK_RANGE_MM_L_NAME "RANGE_MM_L"
#define CMMC_DISTANCE_FORE_FEEDBACK_ERROR_STATUS_L_NAME "ERROR_STATUS_L"
#define CMMC_DISTANCE_FORE_FEEDBACK_SIGNAL_RATE_MCPS_L_NAME "SIGNAL_RATE_MCPS_L"
#define CMMC_DISTANCE_FORE_FEEDBACK_RANGE_MM_R_NAME "RANGE_MM_R"
#define CMMC_DISTANCE_FORE_FEEDBACK_ERROR_STATUS_R_NAME "ERROR_STATUS_R"
#define CMMC_DISTANCE_FORE_FEEDBACK_SIGNAL_RATE_MCPS_R_NAME "SIGNAL_RATE_MCPS_R"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_RANGE_MM_L_NAME "RANGE_MM_L"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_ERROR_STATUS_L_NAME "ERROR_STATUS_L"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_SIGNAL_RATE_MCPS_L_NAME "SIGNAL_RATE_MCPS_L"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_RANGE_MM_R_NAME "RANGE_MM_R"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_ERROR_STATUS_R_NAME "ERROR_STATUS_R"
#define CMMC_DISTANCE_ACHTER_FEEDBACK_SIGNAL_RATE_MCPS_R_NAME "SIGNAL_RATE_MCPS_R"
#define CMMC_DISTANCE_BOW_FEEDBACK_RANGE_MM_NAME "RANGE_MM"
#define CMMC_DISTANCE_BOW_FEEDBACK_ERROR_STATUS_NAME "ERROR_STATUS"
#define CMMC_DISTANCE_BOW_FEEDBACK_SIGNAL_RATE_MCPS_NAME "SIGNAL_RATE_MCPS"

/**
 * Signals in message ODRIVE_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_heartbeat_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_current_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_error_flag;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_error_flag;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_error_flag;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trajectory_done_flag;
};

/**
 * Signals in message ODRIVE_SET_REQUESTED_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_set_requested_state_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message ODRIVE_SET_INPUT_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t torque_ff;
};

/**
 * Signals in message ODRIVE_GET_IQ.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t iq_measured;
};

/**
 * Signals in message ODRIVE_GET_SENSORLESS_ESTIMATES.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_vel_estimate;
};

/**
 * Signals in message ODRIVE_GET_BUS_VOLTAGE_CURRENT.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_get_bus_voltage_current_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t bus_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t bus_current;
};

/**
 * Signals in message ODRIVE_CLEAR_ERRORS.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_odrive_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message RADIO_CONTROL.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_radio_control_t {
    /**
     * Range: -1000..1000 (-1000..1000 permile)
     * Scale: 1
     * Offset: 0
     */
    int16_t throttle;

    /**
     * Range: -1000..1000 (-1000..1000 permile)
     * Scale: 1
     * Offset: 0
     */
    int16_t steering;

    /**
     * Range: -1000..1000 (-1000..1000 permile)
     * Scale: 1
     * Offset: 0
     */
    int16_t front_pitch;

    /**
     * Range: -1000..1000 (-1000..1000 permile)
     * Scale: 1
     * Offset: 0
     */
    int16_t front_roll;

    /**
     * Range: -1000..1000 (-1000..1000 permile)
     * Scale: 1
     * Offset: 0
     */
    int16_t rear_pitch;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t free_bits;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t arm_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode_switch;
};

/**
 * Signals in message ACTUATOR_CONFIGURATION.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_actuator_configuration_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t request;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t actuator;
};

/**
 * Signals in message ACTUATOR_RIGHT_FOIL_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_actuator_right_foil_feedback_t {
    /**
     * Range: -500..500 (-1.0..1.0 A)
     * Scale: 0.002
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: 0..1000 (3.6..6.6 V)
     * Scale: 0.003
     * Offset: 3.6
     */
    uint16_t voltage;

    /**
     * Range: -120..120 (-6..6 W)
     * Scale: 0.05
     * Offset: 0
     */
    int8_t power;

    /**
     * Range: 0..1023 (988..2011 us)
     * Scale: 1
     * Offset: 988
     */
    uint16_t setpoint_us;

    /**
     * Range: 0..4091 (0..4091 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t position_raw;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t free_bits;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message ACTUATOR_LEFT_FOIL_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_actuator_left_foil_feedback_t {
    /**
     * Range: -500..500 (-1.0..1.0 A)
     * Scale: 0.002
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: 0..1000 (3.6..6.6 V)
     * Scale: 0.003
     * Offset: 3.6
     */
    uint16_t voltage;

    /**
     * Range: -120..120 (-6..6 W)
     * Scale: 0.05
     * Offset: 0
     */
    int8_t power;

    /**
     * Range: 0..1023 (988..2011 us)
     * Scale: 1
     * Offset: 988
     */
    uint16_t setpoint_us;

    /**
     * Range: 0..4091 (0..4091 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t position_raw;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t free_bits;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message ACTUATOR_REAR_FOIL_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_actuator_rear_foil_feedback_t {
    /**
     * Range: -500..500 (-1.0..1.0 A)
     * Scale: 0.002
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: 0..1000 (3.6..6.6 V)
     * Scale: 0.003
     * Offset: 3.6
     */
    uint16_t voltage;

    /**
     * Range: -120..120 (-6..6 W)
     * Scale: 0.05
     * Offset: 0
     */
    int8_t power;

    /**
     * Range: 0..1023 (988..2011 us)
     * Scale: 1
     * Offset: 988
     */
    uint16_t setpoint_us;

    /**
     * Range: 0..4091 (0..4091 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t position_raw;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t free_bits;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message ACTUATOR_STEERING_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_actuator_steering_feedback_t {
    /**
     * Usable current range is around +/- 1A, because of 82mOhm shunt resistors used
     *
     * Range: -500..500 (-1.0..1.0 A)
     * Scale: 0.002
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: 0..1000 (3.6..6.6 V)
     * Scale: 0.003
     * Offset: 3.6
     */
    uint16_t voltage;

    /**
     * Range: -120..120 (-6..6 W)
     * Scale: 0.05
     * Offset: 0
     */
    int8_t power;

    /**
     * Range: 0..1023 (988..2011 us)
     * Scale: 1
     * Offset: 988
     */
    uint16_t setpoint_us;

    /**
     * Range: 0..4091 (0..4091 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t position_raw;

    /**
     * TODO - feedback of the setpoint in degrees but the ranges are different for steering and foils
     *
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t free_bits;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message DISTANCE_FORE_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_distance_fore_feedback_t {
    /**
     * Range: 0..255 (0..255 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_mm_l;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_status_l;

    /**
     * Range: 0..1280 (0..10 MCPS)
     * Scale: 0.0078125
     * Offset: 0
     */
    uint16_t signal_rate_mcps_l;

    /**
     * Range: 0..255 (0..255 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_mm_r;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_status_r;

    /**
     * Range: 0..1280 (0..10 MCPS)
     * Scale: 0.0078125
     * Offset: 0
     */
    uint16_t signal_rate_mcps_r;
};

/**
 * Signals in message DISTANCE_ACHTER_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_distance_achter_feedback_t {
    /**
     * Range: 0..255 (0..255 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_mm_l;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_status_l;

    /**
     * Range: 0..1280 (0..10 MCPS)
     * Scale: 0.0078125
     * Offset: 0
     */
    uint16_t signal_rate_mcps_l;

    /**
     * Range: 0..255 (0..255 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_mm_r;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_status_r;

    /**
     * Range: 0..1280 (0..10 MCPS)
     * Scale: 0.0078125
     * Offset: 0
     */
    uint16_t signal_rate_mcps_r;
};

/**
 * Signals in message DISTANCE_BOW_FEEDBACK.
 *
 * All signal values are as on the CAN bus.
 */
struct cmmc_distance_bow_feedback_t {
    /**
     * Range: 0..255 (0..255 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_mm;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_status;

    /**
     * Range: 0..1280 (0..10 MCPS)
     * Scale: 0.0078125
     * Offset: 0
     */
    uint16_t signal_rate_mcps;
};

/**
 * Pack message ODRIVE_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_heartbeat_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_heartbeat_unpack(
    struct cmmc_odrive_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_HEARTBEAT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_heartbeat_init(struct cmmc_odrive_heartbeat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_heartbeat_axis_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_odrive_heartbeat_axis_current_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_axis_current_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_axis_current_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_odrive_heartbeat_motor_error_flag_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_motor_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_motor_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_odrive_heartbeat_encoder_error_flag_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_encoder_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_encoder_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_odrive_heartbeat_controller_error_flag_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_controller_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_controller_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_odrive_heartbeat_trajectory_done_flag_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_heartbeat_trajectory_done_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_heartbeat_trajectory_done_flag_is_in_range(uint8_t value);

/**
 * Pack message ODRIVE_SET_REQUESTED_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_set_requested_state_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_set_requested_state_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_SET_REQUESTED_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_set_requested_state_unpack(
    struct cmmc_odrive_set_requested_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_SET_REQUESTED_STATE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_set_requested_state_init(struct cmmc_odrive_set_requested_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_set_requested_state_axis_requested_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_set_requested_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_set_requested_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message ODRIVE_SET_INPUT_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_set_input_vel_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_SET_INPUT_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_set_input_vel_unpack(
    struct cmmc_odrive_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_SET_INPUT_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_set_input_vel_init(struct cmmc_odrive_set_input_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_set_input_vel_input_vel_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_set_input_vel_input_vel_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_set_input_vel_input_vel_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_set_input_vel_torque_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_set_input_vel_torque_ff_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_set_input_vel_torque_ff_is_in_range(uint32_t value);

/**
 * Pack message ODRIVE_GET_IQ.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_get_iq_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_GET_IQ.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_get_iq_unpack(
    struct cmmc_odrive_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_GET_IQ.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_get_iq_init(struct cmmc_odrive_get_iq_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_iq_iq_setpoint_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_iq_iq_setpoint_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_iq_iq_setpoint_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_iq_iq_measured_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_iq_iq_measured_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_iq_iq_measured_is_in_range(uint32_t value);

/**
 * Pack message ODRIVE_GET_SENSORLESS_ESTIMATES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_GET_SENSORLESS_ESTIMATES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_get_sensorless_estimates_unpack(
    struct cmmc_odrive_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_GET_SENSORLESS_ESTIMATES.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_get_sensorless_estimates_init(struct cmmc_odrive_get_sensorless_estimates_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(uint32_t value);

/**
 * Pack message ODRIVE_GET_BUS_VOLTAGE_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_get_bus_voltage_current_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_get_bus_voltage_current_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_GET_BUS_VOLTAGE_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_get_bus_voltage_current_unpack(
    struct cmmc_odrive_get_bus_voltage_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_GET_BUS_VOLTAGE_CURRENT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_get_bus_voltage_current_init(struct cmmc_odrive_get_bus_voltage_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_bus_voltage_current_bus_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_bus_voltage_current_bus_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_bus_voltage_current_bus_voltage_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t cmmc_odrive_get_bus_voltage_current_bus_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_odrive_get_bus_voltage_current_bus_current_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_odrive_get_bus_voltage_current_bus_current_is_in_range(uint32_t value);

/**
 * Pack message ODRIVE_CLEAR_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_odrive_clear_errors_pack(
    uint8_t *dst_p,
    const struct cmmc_odrive_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_CLEAR_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_odrive_clear_errors_unpack(
    struct cmmc_odrive_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODRIVE_CLEAR_ERRORS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_odrive_clear_errors_init(struct cmmc_odrive_clear_errors_t *msg_p);

/**
 * Pack message RADIO_CONTROL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_radio_control_pack(
    uint8_t *dst_p,
    const struct cmmc_radio_control_t *src_p,
    size_t size);

/**
 * Unpack message RADIO_CONTROL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_radio_control_unpack(
    struct cmmc_radio_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RADIO_CONTROL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_radio_control_init(struct cmmc_radio_control_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_radio_control_throttle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_throttle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_throttle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_radio_control_steering_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_steering_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_steering_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_radio_control_front_pitch_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_front_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_front_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_radio_control_front_roll_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_front_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_front_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_radio_control_rear_pitch_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_rear_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_rear_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_radio_control_free_bits_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_free_bits_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_free_bits_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_radio_control_arm_switch_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_arm_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_arm_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_radio_control_mode_switch_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_radio_control_mode_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_radio_control_mode_switch_is_in_range(uint8_t value);

/**
 * Pack message ACTUATOR_CONFIGURATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_actuator_configuration_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_configuration_t *src_p,
    size_t size);

/**
 * Unpack message ACTUATOR_CONFIGURATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_actuator_configuration_unpack(
    struct cmmc_actuator_configuration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACTUATOR_CONFIGURATION.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_actuator_configuration_init(struct cmmc_actuator_configuration_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_configuration_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_configuration_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_configuration_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_configuration_actuator_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_configuration_actuator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_configuration_actuator_is_in_range(uint8_t value);

/**
 * Pack message ACTUATOR_RIGHT_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_actuator_right_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_right_foil_feedback_t *src_p,
    size_t size);

/**
 * Unpack message ACTUATOR_RIGHT_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_actuator_right_foil_feedback_unpack(
    struct cmmc_actuator_right_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACTUATOR_RIGHT_FOIL_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_actuator_right_foil_feedback_init(struct cmmc_actuator_right_foil_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_actuator_right_foil_feedback_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_right_foil_feedback_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t cmmc_actuator_right_foil_feedback_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_power_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_power_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_right_foil_feedback_setpoint_us_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_setpoint_us_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_setpoint_us_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_right_foil_feedback_position_raw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_position_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_position_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_right_foil_feedback_free_bits_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_free_bits_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_free_bits_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_right_foil_feedback_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_right_foil_feedback_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_right_foil_feedback_mode_is_in_range(uint8_t value);

/**
 * Pack message ACTUATOR_LEFT_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_actuator_left_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_left_foil_feedback_t *src_p,
    size_t size);

/**
 * Unpack message ACTUATOR_LEFT_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_actuator_left_foil_feedback_unpack(
    struct cmmc_actuator_left_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACTUATOR_LEFT_FOIL_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_actuator_left_foil_feedback_init(struct cmmc_actuator_left_foil_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_actuator_left_foil_feedback_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_left_foil_feedback_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t cmmc_actuator_left_foil_feedback_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_power_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_power_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_left_foil_feedback_setpoint_us_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_setpoint_us_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_setpoint_us_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_left_foil_feedback_position_raw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_position_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_position_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_left_foil_feedback_free_bits_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_free_bits_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_free_bits_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_left_foil_feedback_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_left_foil_feedback_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_left_foil_feedback_mode_is_in_range(uint8_t value);

/**
 * Pack message ACTUATOR_REAR_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_actuator_rear_foil_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_rear_foil_feedback_t *src_p,
    size_t size);

/**
 * Unpack message ACTUATOR_REAR_FOIL_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_actuator_rear_foil_feedback_unpack(
    struct cmmc_actuator_rear_foil_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACTUATOR_REAR_FOIL_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_actuator_rear_foil_feedback_init(struct cmmc_actuator_rear_foil_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_actuator_rear_foil_feedback_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_rear_foil_feedback_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t cmmc_actuator_rear_foil_feedback_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_power_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_power_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_rear_foil_feedback_setpoint_us_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_setpoint_us_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_setpoint_us_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_rear_foil_feedback_position_raw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_position_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_position_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_rear_foil_feedback_free_bits_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_free_bits_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_free_bits_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_rear_foil_feedback_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_rear_foil_feedback_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_rear_foil_feedback_mode_is_in_range(uint8_t value);

/**
 * Pack message ACTUATOR_STEERING_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_actuator_steering_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_actuator_steering_feedback_t *src_p,
    size_t size);

/**
 * Unpack message ACTUATOR_STEERING_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_actuator_steering_feedback_unpack(
    struct cmmc_actuator_steering_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACTUATOR_STEERING_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_actuator_steering_feedback_init(struct cmmc_actuator_steering_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t cmmc_actuator_steering_feedback_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_steering_feedback_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t cmmc_actuator_steering_feedback_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_power_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_power_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_steering_feedback_setpoint_us_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_setpoint_us_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_setpoint_us_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_steering_feedback_position_raw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_position_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_position_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_actuator_steering_feedback_free_bits_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_free_bits_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_free_bits_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_actuator_steering_feedback_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_actuator_steering_feedback_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_actuator_steering_feedback_mode_is_in_range(uint8_t value);

/**
 * Pack message DISTANCE_FORE_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_distance_fore_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_fore_feedback_t *src_p,
    size_t size);

/**
 * Unpack message DISTANCE_FORE_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_distance_fore_feedback_unpack(
    struct cmmc_distance_fore_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DISTANCE_FORE_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_distance_fore_feedback_init(struct cmmc_distance_fore_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_fore_feedback_range_mm_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_range_mm_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_range_mm_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_fore_feedback_error_status_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_error_status_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_error_status_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_distance_fore_feedback_signal_rate_mcps_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_signal_rate_mcps_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_signal_rate_mcps_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_fore_feedback_range_mm_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_range_mm_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_range_mm_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_fore_feedback_error_status_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_error_status_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_error_status_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_distance_fore_feedback_signal_rate_mcps_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_fore_feedback_signal_rate_mcps_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_fore_feedback_signal_rate_mcps_r_is_in_range(uint16_t value);

/**
 * Pack message DISTANCE_ACHTER_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_distance_achter_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_achter_feedback_t *src_p,
    size_t size);

/**
 * Unpack message DISTANCE_ACHTER_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_distance_achter_feedback_unpack(
    struct cmmc_distance_achter_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DISTANCE_ACHTER_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_distance_achter_feedback_init(struct cmmc_distance_achter_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_achter_feedback_range_mm_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_range_mm_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_range_mm_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_achter_feedback_error_status_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_error_status_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_error_status_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_distance_achter_feedback_signal_rate_mcps_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_signal_rate_mcps_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_signal_rate_mcps_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_achter_feedback_range_mm_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_range_mm_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_range_mm_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_achter_feedback_error_status_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_error_status_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_error_status_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_distance_achter_feedback_signal_rate_mcps_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_achter_feedback_signal_rate_mcps_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_achter_feedback_signal_rate_mcps_r_is_in_range(uint16_t value);

/**
 * Pack message DISTANCE_BOW_FEEDBACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int cmmc_distance_bow_feedback_pack(
    uint8_t *dst_p,
    const struct cmmc_distance_bow_feedback_t *src_p,
    size_t size);

/**
 * Unpack message DISTANCE_BOW_FEEDBACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int cmmc_distance_bow_feedback_unpack(
    struct cmmc_distance_bow_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DISTANCE_BOW_FEEDBACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int cmmc_distance_bow_feedback_init(struct cmmc_distance_bow_feedback_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_bow_feedback_range_mm_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_bow_feedback_range_mm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_bow_feedback_range_mm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t cmmc_distance_bow_feedback_error_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_bow_feedback_error_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_bow_feedback_error_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t cmmc_distance_bow_feedback_signal_rate_mcps_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float cmmc_distance_bow_feedback_signal_rate_mcps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool cmmc_distance_bow_feedback_signal_rate_mcps_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
